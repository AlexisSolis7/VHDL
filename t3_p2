library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.NUMERIC_STD.ALL;

entity projeto_2_serial is
    Port ( 
	 -- controle
			  clock: in STD_LOGIC;
			  palavra : in  STD_LOGIC_VECTOR(7 downto 0);
           send : in  STD_LOGIC;
           busy : out  STD_LOGIC;
           linha : out  STD_LOGIC;
           reset : in  STD_LOGIC
	);
end projeto_2_serial;

architecture Behavioral of projeto_2_serial is
	-- registrador
		reg_storage : std_logic_vector(7 downto 0);
	-- contador
		signal contador_enable : STD_LOGIC;
		signal contador_load : STD_LOGIC;
		signal contador_zeros : std_logic_vector(2 downto 0);
begin
-- controle
process(clock, reset, palavra, )
--	if (send'event and send='1') then
	if (busy='0' and send='1') then
	 linha <= '0';
	elsif (busy='0' and contador_zeros /= "000") then
		linha <= '0';
	elsif (busy='1' and contador_zeros /= "000") then
		linha <= palavra; -- checar isso
		
	end if;
end process;

-- contador
process(clock, reset)
if (reset = '1') then 
		contador_zeros <= (Others => '0');
elsif (rising_edge(clock)) then
	   if (contador_load = '1') then
			contador_zeros <= (Others => '1);
		end if;
		if (contador_enable = '1') then
			contador_zeros <= contador_zeros - '1';
		end if;
end if;
end process;


-- registrador
process(clock, reset)
   if (reset = '1') then 
		reg_storage <= (Others => '0');
	elsif (rising_edge(clock)) then
		if (contador_enable = '1') then
			reg_storage <= palavra;
		end if;
	end if;
end process;

end Behavioral;



-- MUX


-- Declaração da entidade do MUX
entity mux_8bits is
    port (
        sel : in std_logic_vector(2 downto 0); -- Seletor de 3 bits para escolher qual bit do registrador usar
        Q : in std_logic_vector(7 downto 0); -- Entrada de dados de 8 bits (saída do registrador)
        saida : out std_logic -- Saída de um único bit selecionado
    );
end mux_8bits;

-- Arquitetura do MUX
architecture Behavioral of mux_8bits is
begin
    -- Processo que determina a saída com base no seletor
    process(sel, Q) 
    begin
        case sel is -- Início da estrutura de seleção
            when "000" => saida <= Q(0); -- Se sel é 0, pega o bit 0 de Q
            when "001" => saida <= Q(1); -- Se sel é 1, pega o bit 1 de Q
            when "010" => saida <= Q(2); -- Se sel é 2, pega o bit 2 de Q
            when "011" => saida <= Q(3); -- Se sel é 3, pega o bit 3 de Q
            when "100" => saida <= Q(4); -- Se sel é 4, pega o bit 4 de Q
            when "101" => saida <= Q(5); -- Se sel é 5, pega o bit 5 de Q
            when "110" => saida <= Q(6); -- Se sel é 6, pega o bit 6 de Q
            when "111" => saida <= Q(7); -- Se sel é 7, pega o bit 7 de Q
            when others => saida <= '0'; -- Caso nenhum valor se encaixe, seta a saída como 0
        end case; -- Fim da estrutura de seleção
    end process; -- Fim do processo
end Behavioral; -- Fim da arquitetura

