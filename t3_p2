library IEEE;
use IEEE.STD_LOGIC_1164.ALL;
use IEEE.STD_LOGIC_UNSIGNED.ALL;
use IEEE.STD_LOGIC_ARITH.ALL;

entity projeto_2_serial is
    Port ( 
	 -- controle
			  clock : in STD_LOGIC;
           reset : in  STD_LOGIC;
			  
			  palavra : in  STD_LOGIC_VECTOR(7 downto 0);
           send : in  STD_LOGIC;
           
			  busy : out  STD_LOGIC;
           linha : out  STD_LOGIC
	);
end projeto_2_serial;

architecture Behavioral of projeto_2_serial is
	-- registrador
		signal reg_storage : std_logic_vector(7 downto 0);
	-- contador
		signal contador_enable : STD_LOGIC;
		signal contador_load : STD_LOGIC;
		signal contador_zeros : std_logic_vector(2 downto 0);
		
	-- MUXs
		signal selected_bit : std_logic;
		signal mux_2 : std_logic;
		
	-- XOR
		signal xor_controle: STD_LOGIC;
		
	---- maquina de estados
		type STATES is (S0, S1, S2, S3); -- enum
		-- S0 -> Aguardando
		-- S1 -> Inicializando
		-- S2 -> Transmitindo
		-- S3 -> Finalizando
		signal scurrent, snext: STATES;
begin

-- contador
process(clock, reset)
begin
if (reset = '1') then 
		contador_zeros <= (Others => '0');
elsif (rising_edge(clock)) then
	   if (contador_load = '1') then
			contador_zeros <= (Others => '1');
		end if;
		if (contador_enable = '1') then
			contador_zeros <= contador_zeros - 1;
		end if;
end if;
end process;


-- registrador
process(clock, reset)
begin
   if (reset = '1') then 
		reg_storage <= (Others => '0');
	elsif (rising_edge(clock)) then
		if (contador_enable = '1') then
			reg_storage <= palavra;
		end if;
	end if;
end process;


-- MUX 1
selected_bit <= reg_storage (conv_integer(contador_zeros));

-- MUX 2
mux_2 <= if contador_enable = '1' then selected_bit else '0';

xor_controle <= contador_zeros = "000";

--	maquina de estados
scurrent <= case xor_controle
		when '1' => if send = '1' then S1,
		when '0' => if snext = S1,


end Behavioral; -- Fim da arquitetura
